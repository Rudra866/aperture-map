<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Globe - KML Debug Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/togeojson"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    html, body, #map { height: 100%; width: 100%; margin: 0; padding: 0; }
    #debugLog { position:absolute;top:0;left:0;z-index:9999;color:#fff;background:rgba(0,0,0,0.7);max-width:100vw;max-height:200px;overflow:auto;font-size:12px }
    .mapboxgl-ctrl-attrib { display: none !important; }
    .mapboxgl-ctrl-logo { display: none !important; }
  </style>  
</head>
<body>
  <div id="map"></div>
  <script>
    // ---------------------------
    // Global caches
    // ---------------------------
    window.stationsList = [];
    window.radiusKm = 100;
    window.stationColorMap = {}; // stationId -> { color, value }
    window.__stationsVisible = false; // default OFF
    window.__gridRows = [];
    window.__gridMode = false;
    window.__gridDrawMode = false;
    window.__gridPolygonMode = false;
    window.__gridInterval = 0.5;
    window.__gridMetric = 'precip';
    window.__gridBaseGeoJSON = {type: 'FeatureCollection', features: []};
    window.__gridHighlightGeoJSON = {type: 'FeatureCollection', features: []};
    let __gridIsDrawing = false;
    let __gridStartPoint = null;
    let __gridRectCoords = [];

    const GRID_PRECIP_THRESHOLDS = [0.1,0.25,0.5,0.75,1.0,1.25,1.5,1.75,2.0,2.5,3.0,4.0,5.0,7.0,10.0,15.0,20.0,50.0,100.0,200.0,500.0,1000.0,2000.0,3000.0,4000.0,5000.0];
    const GRID_PRECIP_COLORS = [
      "#631709",
      "#AB2913",
      "#B23113",
      "#FE4B13",
      "#FD5411",
      "#FD6E09",
      "#FE7D03",
      "#C87213",
      "#FEA015",
      "#EFA917",
      "#ECFE13",
      "#9AD415",
      "#88ED00",
      "#66FD13",
      "#19FF63",
      "#17D379",
      "#13D8AE",
      "#15CDFD",
      "#1398E9",
      "#1169DB",
      "#1134DA",
      "#2403FB",
      "#3A06E3",
      "#c191f1",
      "#8f4ed8",
      "#7B13F5",
    ];
    function colorForGridPrecip(val){
      const v = Number(val);
      if (!Number.isFinite(v)) return "rgba(0,0,0,0)";
      for (let i = GRID_PRECIP_THRESHOLDS.length - 1;i>=0;i--){
        if (v >= GRID_PRECIP_THRESHOLDS[i]) return GRID_PRECIP_COLORS[i];
      }
      return GRID_PRECIP_COLORS[0];
    }

    function buildGridFromRows(rows, interval) {
      const cellMap = new Map();

      (rows || []).forEach((r) => {
        const lat = Number(r.latitude);
        const lon = Number(r.longitude);
        const precip = Number(r.totalPrecipitation || 0);
        const stationId = String(r.stationId ?? "").trim();

        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

        const cellLon = Math.floor(lon / interval) * interval;
        const cellLat = Math.floor(lat / interval) * interval;
        const key = `${cellLon}_${cellLat}`;

        if (!cellMap.has(key)) {
          cellMap.set(key, {
            lon: cellLon,
            lat: cellLat,
            values: [],
            stationIds: [],
            rows: [],
          });
        }

        const cell = cellMap.get(key);
        cell.values.push(precip);
        if (stationId) cell.stationIds.push(stationId);
        cell.rows.push(r);
      });

      const features = [];

      for (const [, cell] of cellMap.entries()) {
        const avg =
          cell.values.length > 0
            ? cell.values.reduce((a, b) => a + b, 0) / cell.values.length
            : 0;

        features.push({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [[
              [cell.lon, cell.lat],
              [cell.lon + interval, cell.lat],
              [cell.lon + interval, cell.lat + interval],
              [cell.lon, cell.lat + interval],
              [cell.lon, cell.lat],
            ]],
          },
          properties: {
            id: `${cell.lon}_${cell.lat}`,
            longitude: cell.lon,
            latitude: cell.lat,
            avgPrecipitation: avg,
            stationIds: [...new Set(cell.stationIds)],
            stationCount: cell.stationIds.length,
            color: colorForGridPrecip(avg),
            isHighlighted: false,
          },
        });
      }

      return {
        type: "FeatureCollection",
        features,
      };
    }

    function ensureGridLayers() {
      addOrUpdateSource("intensity-grid", window.__gridBaseGeoJSON);
      addOrUpdateSource("intensity-grid-highlight", window.__gridHighlightGeoJSON);
      addOrUpdateSource("grid-draw-rect", {
        type: "Feature",
        geometry: { type: "Polygon", coordinates: [[]] },
      });

      if (!map.getLayer("intensity-grid-fill")) {
        map.addLayer({
          id: "intensity-grid-fill",
          type: "fill",
          source: "intensity-grid",
          paint: {
            "fill-color": ["coalesce", ["get", "color"], "rgba(0,0,0,0)"],
            "fill-opacity": 0.22,
          },
        });
      }

      if (!map.getLayer("intensity-grid-line")) {
        map.addLayer({
          id: "intensity-grid-line",
          type: "line",
          source: "intensity-grid",
          paint: {
            "line-color": "#666",
            "line-width": 0.5,
          },
        });
      }

      if (!map.getLayer("intensity-grid-highlight-fill")) {
        map.addLayer({
          id: "intensity-grid-highlight-fill",
          type: "fill",
          source: "intensity-grid-highlight",
          paint: {
            "fill-color": ["get", "color"],
            "fill-opacity": 0.9,
          },
        });
      }

      if (!map.getLayer("grid-draw-rect-line")) {
        map.addLayer({
          id: "grid-draw-rect-line",
          type: "line",
          source: "grid-draw-rect",
          paint: {
            "line-color": "#ff6600",
            "line-width": 3,
          },
        });
      }
    }

    function renderGridFromRows(rows, interval) {
      window.__gridRows = rows || [];
      window.__gridInterval = interval || 0.5;
      window.__gridBaseGeoJSON = buildGridFromRows(window.__gridRows, window.__gridInterval);
      window.__gridHighlightGeoJSON = { type: "FeatureCollection", features: [] };

      ensureGridLayers();

      map.getSource("intensity-grid").setData(window.__gridBaseGeoJSON);
      map.getSource("intensity-grid-highlight").setData(window.__gridHighlightGeoJSON);

      const hasGrid = !!window.__gridMode;
      map.setLayoutProperty("intensity-grid-fill", "visibility", hasGrid ? "visible" : "none");
      map.setLayoutProperty("intensity-grid-line", "visibility", hasGrid ? "visible" : "none");
      map.setLayoutProperty("intensity-grid-highlight-fill", "visibility", hasGrid ? "visible" : "none");
      map.setLayoutProperty("grid-draw-rect-line", "visibility", hasGrid ? "visible" : "none");
    }

    function clearGrid() {
      window.__gridRows = [];
      window.__gridBaseGeoJSON = { type: "FeatureCollection", features: [] };
      window.__gridHighlightGeoJSON = { type: "FeatureCollection", features: [] };

      if (map.getSource("intensity-grid")) {
        map.getSource("intensity-grid").setData(window.__gridBaseGeoJSON);
      }
      if (map.getSource("intensity-grid-highlight")) {
        map.getSource("intensity-grid-highlight").setData(window.__gridHighlightGeoJSON);
      }
      if (map.getSource("grid-draw-rect")) {
        map.getSource("grid-draw-rect").setData({
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [[]] },
        });
      }
    }
    function updateGridRect(coords) {
      if (!map.getSource("grid-draw-rect")) return;
      map.getSource("grid-draw-rect").setData({
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: coords,
        },
      });
    }

    function onGridMouseMove(e) {
      if (!window.__gridDrawMode || !__gridIsDrawing || !__gridStartPoint) return;

      const endPoint = e.lngLat;

      __gridRectCoords = [[
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [endPoint.lng, __gridStartPoint.lat],
        [endPoint.lng, endPoint.lat],
        [__gridStartPoint.lng, endPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
      ]];

      updateGridRect(__gridRectCoords);
    }

    // Compute [ [minLng, minLat], [maxLng, maxLat] ] from the drawn rectangle
    function getBoundsFromRect(rectCoords) {
      if (!rectCoords || !rectCoords.length || !rectCoords[0].length) return null;
      const ring = rectCoords[0];
      let minLng = ring[0][0];
      let maxLng = ring[0][0];
      let minLat = ring[0][1];
      let maxLat = ring[0][1];
      for (let i = 1; i < ring.length; i++) {
        const pt = ring[i];
        if (!pt) continue;
        const lng = pt[0];
        const lat = pt[1];
        if (!Number.isFinite(lng) || !Number.isFinite(lat)) continue;
        if (lng < minLng) minLng = lng;
        if (lng > maxLng) maxLng = lng;
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
      }
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    // Build a full grid (including empty cells) just inside the dragged rectangle
    function buildFullGridForBounds(bounds, interval, rows) {
      if (!bounds) return { type: "FeatureCollection", features: [] };
      const [[minLngRaw, minLatRaw], [maxLngRaw, maxLatRaw]] = bounds;
      const intervalVal = Number(interval) || 0.5;
      const minLng = Math.min(minLngRaw, maxLngRaw);
      const maxLng = Math.max(minLngRaw, maxLngRaw);
      const minLat = Math.min(minLatRaw, maxLatRaw);
      const maxLat = Math.max(minLatRaw, maxLatRaw);

      const startLon = Math.floor(minLng / intervalVal) * intervalVal;
      const endLon = Math.ceil(maxLng / intervalVal) * intervalVal;
      const startLat = Math.floor(minLat / intervalVal) * intervalVal;
      const endLat = Math.ceil(maxLat / intervalVal) * intervalVal;

      const cellAccum = new Map();

      (rows || []).forEach((r) => {
        const lat = Number(r.latitude);
        const lon = Number(r.longitude);
        const precip = Number(r.totalPrecipitation || 0);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
        if (lon < startLon || lon > endLon || lat < startLat || lat > endLat) return;

        const cellLon = Math.floor(lon / intervalVal) * intervalVal;
        const cellLat = Math.floor(lat / intervalVal) * intervalVal;
        const key = `${cellLon}_${cellLat}`;

        if (!cellAccum.has(key)) {
          cellAccum.set(key, { lon: cellLon, lat: cellLat, sum: 0, count: 0 });
        }
        const cell = cellAccum.get(key);
        if (Number.isFinite(precip)) {
          cell.sum += precip;
          cell.count += 1;
        }
      });

      const features = [];

      for (let lng = startLon; lng < endLon; lng += intervalVal) {
        for (let lat = startLat; lat < endLat; lat += intervalVal) {
          const key = `${lng}_${lat}`;
          const accum = cellAccum.get(key) || { sum: 0, count: 0 };
          const hasData = accum.count > 0;
          const value = hasData ? accum.sum / accum.count : null;

          features.push({
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [[
                [lng, lat],
                [lng + intervalVal, lat],
                [lng + intervalVal, lat + intervalVal],
                [lng, lat + intervalVal],
                [lng, lat],
              ]],
            },
            properties: {
              id: `${lng}_${lat}`,
              longitude: lng,
              latitude: lat,
              avgPrecipitation: value,
              isReal: hasData,
            },
          });
        }
      }

      return { type: "FeatureCollection", features };
    }

    // Fill empty cells inside a small local grid by propagating from nearby real cells
    function fillEmptyCellsByPropagation(gridFC) {
      const features = (gridFC && gridFC.features) || [];
      if (!features.length) return gridFC;

      const realCells = [];
      const emptyCells = [];

      for (let i = 0; i < features.length; i++) {
        const f = features[i];
        const v = f.properties && f.properties.avgPrecipitation;
        const isReal = f.properties && f.properties.isReal;
        const coords = f.geometry && f.geometry.coordinates && f.geometry.coordinates[0];
        if (!coords || !coords.length) continue;
        const center = [
          (coords[0][0] + coords[2][0]) / 2,
          (coords[0][1] + coords[2][1]) / 2,
        ];
        if (isReal && Number.isFinite(v)) {
          realCells.push({ index: i, value: Number(v), center });
        } else {
          emptyCells.push({ index: i, center });
        }
      }

      if (!realCells.length) {
        return gridFC;
      }

      const K = 5;
      emptyCells.forEach((cell) => {
        const distances = realCells.map((rc) => {
          const d = turf.distance(
            turf.point(cell.center),
            turf.point(rc.center),
            { units: "kilometers" },
          );
          return { rc, d };
        });
        distances.sort((a, b) => a.d - b.d);
        const neighbors = distances.slice(0, K).filter((x) => x.d > 0);
        if (!neighbors.length) return;

        let num = 0;
        let den = 0;
        neighbors.forEach(({ rc, d }) => {
          const w = 1 / Math.pow(d + 0.0001, 2);
          num += rc.value * w;
          den += w;
        });
        if (den > 0) {
          const inferred = num / den;
          const f = features[cell.index];
          f.properties.avgPrecipitation = inferred;
          f.properties.isReal = false;
        }
      });

      return gridFC;
    }

    function finishGridSelection() {
      if (!__gridRectCoords.length) return;

      const bounds = getBoundsFromRect(__gridRectCoords);
      const interval = window.__gridInterval || 0.5;
      const rows = window.__gridRows || [];

      const localGrid = buildFullGridForBounds(bounds, interval, rows);
      const filledGrid = fillEmptyCellsByPropagation(localGrid);

      filledGrid.features.forEach((f) => {
        const v = f.properties && f.properties.avgPrecipitation;
        if (Number.isFinite(v)) {
          f.properties.color = colorForGridPrecip(v);
          f.properties.isHighlighted = true;
        } else {
          f.properties.color = "rgba(0,0,0,0)";
          f.properties.isHighlighted = false;
        }
      });

      window.__gridHighlightGeoJSON = filledGrid;

      if (map.getSource("intensity-grid-highlight")) {
        map.getSource("intensity-grid-highlight").setData(window.__gridHighlightGeoJSON);
      }

      if (map.getSource("grid-draw-rect")) {
        map.getSource("grid-draw-rect").setData({
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [[]] },
        });
      }

      __gridRectCoords = [];
      __gridStartPoint = null;
    }

    function setStationsVisibility(vis) {
      window.__stationsVisible = !!vis;
      const lyr = map.getLayer('station-points');
      if (lyr) {
        map.setLayoutProperty('station-points', 'visibility', window.__stationsVisible ? 'visible' : 'none');
      }
    }
    if (window.ReactNativeWebView) {
    window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'WEB_READY' }));
    }

    let lastKmlAllGeoJSON = null;
    let lastSelectedGeoJSON = null;
    let lastSelectionCenter = null;
    let lastSelectionRadiusKm = null;
    let kmlFeatures = [];
    let lastUserLoc = null;
    let autoCentered = false;

    function createCircleGeoJSONMeters(center, radiusMeters, points = 64) {
    const [lng, lat] = center;
    const radiusKm = Math.max((radiusMeters || 0) / 1000, 0.005); // min ring
    const coords = [];
    for (let i = 0; i <= points; i++) {
      const a = (i / points) * 2 * Math.PI;
      const dx = radiusKm * Math.cos(a);
      const dy = radiusKm * Math.sin(a);
      const dLng = dx / (111.32 * Math.cos(lat * Math.PI / 180));
      const dLat = dy / 110.574;
      coords.push([lng + dLng, lat + dLat]);
    }
    return {
      type: "FeatureCollection",
      features: [{ type: "Feature", geometry: { type: "Polygon", coordinates: [coords] }, properties: {} }]
      };
    }

    function upsertUserLocation(lng, lat, accuracy) {
    lastUserLoc = { lng, lat, accuracy };

      const point = {
        type: "FeatureCollection",
        features: [{ type: "Feature", geometry: { type: "Point", coordinates: [lng, lat] }, properties: {} }]
      };
      const ring = createCircleGeoJSONMeters([lng, lat], accuracy);

      addOrUpdateSource("user-location", point);
      addOrUpdateSource("user-location-accuracy", ring);

      if (!map.getLayer("user-location-accuracy")) {
        map.addLayer({
          id: "user-location-accuracy",
          type: "fill",
          source: "user-location-accuracy",
          paint: { "fill-color": "#3b82f6", "fill-opacity": 0.12 }
        });
      }
      if (!map.getLayer("user-location-dot")) {
        map.addLayer({
          id: "user-location-dot",
          type: "circle",
          source: "user-location",
          paint: {
            "circle-radius": 6,
            "circle-color": "#26d81dff",
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff"
          }
        });
      }
      if (!map._userDotClickBound) {
      map.on('click', 'user-location-dot', () => {
        if (lastUserLoc) showUserLocationPopup([lastUserLoc.lng, lastUserLoc.lat]);
      });
      map._userDotClickBound = true;
    }

    }

    function removeUserLocation() {
      lastUserLoc = null;
      if (map.getLayer("user-location-dot")) map.removeLayer("user-location-dot");
      if (map.getLayer("user-location-accuracy")) map.removeLayer("user-location-accuracy");
      if (map.getSource("user-location")) map.removeSource("user-location");
      if (map.getSource("user-location-accuracy")) map.removeSource("user-location-accuracy");
    }

    // Debug log was previously wired to console.log/console.error and rendered
    // into the #debugLog overlay. This caused noisy internal Mapbox messages
    // (like "style not done loading") to appear on top of the screen.
    // Disable this wiring so normal console behavior is restored and
    // nothing is printed into the on-screen overlay.
    //
    // function debug(msg) {
    //   const el = document.getElementById('debugLog');
    //   if (!el) return;
    //   el.textContent += (typeof msg === 'object' ? JSON.stringify(msg, null, 2) : msg) + '\n';
    //   el.scrollTop = el.scrollHeight;
    // }
    // console.log = debug;
    // console.error = debug;

    // ---------------------------
    // Map init
    // ---------------------------
    mapboxgl.accessToken = 'pk.eyJ1Ijoic2hhd25hY2ciLCJhIjoiY21idDFqb25jMHNvcDJpcHZmd28xNWUzayJ9.ruwUPA5XBDkHEoM6pr_bkw';
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      projection: 'globe',
      attributionControl: false,
      zoom: 3.2,
      center: [-98.5, 39.8] // North America default
    });

    map.on('style.load', () => {
      map.setFog({});
      readdAllLayers();
    });
    map.on('load', () => {
    if (window.ReactNativeWebView) {
      window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'MAP_READY' }));
      }
    });

    // ---------------------------
    // Helpers
    // ---------------------------
    function featureBounds(feature) {
      if (!feature) return null;
      let coords = [];
      if (feature.geometry.type === 'Polygon') {
        coords = feature.geometry.coordinates.flat();
      } else if (feature.geometry.type === 'Point') {
        coords = [feature.geometry.coordinates];
      } else if (feature.geometry.type === 'MultiPolygon') {
        coords = feature.geometry.coordinates.flat(2);
      }
      if (!coords.length) return null;
      let minLng = coords[0][0], minLat = coords[0][1], maxLng = coords[0][0], maxLat = coords[0][1];
      coords.forEach(([lng, lat]) => {
        minLng = Math.min(minLng, lng);
        minLat = Math.min(minLat, lat);
        maxLng = Math.max(maxLng, lng);
        maxLat = Math.max(maxLat, lat);
      });
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function parseKmlWithId(raw, id, name) {
      try {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(raw, "text/xml");
        const geojson = toGeoJSON.kml(kmlDoc);
        geojson.features.forEach(f => {
          f.properties = f.properties || {};
          f.properties.kmlId = id;
          f.properties.kmlName = name || id;
        });
        return geojson;
      } catch (e) {
        return { type: "FeatureCollection", features: [] };
      }
    }

    function addOrUpdateSource(id, data) {
      if (map.getSource(id)) {
        map.getSource(id).setData(data);
      } else {
        map.addSource(id, { type: 'geojson', data });
      }
    }

    function addKmlLayers() {
      if (!lastKmlAllGeoJSON) return;
      addOrUpdateSource('kml-data', lastKmlAllGeoJSON);

      if (!map.getLayer('kml-polygon')) {
        map.addLayer({
          id: 'kml-polygon',
          type: 'fill',
          source: 'kml-data',
          paint: { 'fill-color': '#00FF80', 'fill-opacity': 0.4 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-outline')) {
        map.addLayer({
          id: 'kml-outline',
          type: 'line',
          source: 'kml-data',
          paint: { 'line-color': '#fff', 'line-width': 2 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-point')) {
        map.addLayer({
          id: 'kml-point',
          type: 'circle',
          source: 'kml-data',
          paint: { 'circle-radius': 6, 'circle-color': '#ff0' },
          filter: ['==', '$type', 'Point']
        });
      }
    }

    function addStationsLayer() {
      const stylesMap = window.stationColorMap || {};
      const stationFeatures = (window.stationsList || [])
        .filter(st => st.latitude != null && st.longitude != null &&
                      !isNaN(Number(st.latitude)) && !isNaN(Number(st.longitude)))
        .map(st => {
          const sid = String(st.stationId ?? st.station_id ?? '');
          const style = stylesMap[sid] || null;
          return {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [parseFloat(st.longitude), parseFloat(st.latitude)] },
            properties: {
              name: st.stationName || st.name || sid,
              sid,
              col: style ? style.color : null,
              intensity: style ? style.value : null
            }
          };
        });
      const gj = { type: 'FeatureCollection', features: stationFeatures };
      addOrUpdateSource('stations', gj);
      if (!map.getLayer('station-points')) {
        map.addLayer({
          id: 'station-points',
          type: 'circle',
          source: 'stations',
          paint: {
            'circle-radius': 4,
            'circle-color': ['coalesce', ['get', 'col'], '#ff5500'],
            'circle-stroke-color': '#000',
            'circle-stroke-width': ['case', ['has', 'intensity'], 0.5, 0.2]
          },
          layout: {
            visibility: window.__stationsVisible ? 'visible' : 'none'
          }
        });
      } else {
        map.setLayoutProperty('station-points', 'visibility', window.__stationsVisible ? 'visible' : 'none');
      }

    }

    function createCircleGeoJSON(center, radiusKm, points = 64) {
      const [lng, lat] = center;
      const coords = [];
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        const dx = radiusKm * Math.cos(angle);
        const dy = radiusKm * Math.sin(angle);
        const dLng = dx / (111.32 * Math.cos(lat * Math.PI / 180));
        const dLat = dy / 110.574;
        coords.push([lng + dLng, lat + dLat]);
      }
      return {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: { type: 'Polygon', coordinates: [coords] },
          properties: {}
        }]
      };
    }

        // --- long-press state ---
    let __lpTimer = null;
    let __lpStart = null;
    let __activePopup = null;
    // When we long-press a station, set this so the subsequent 'click' is ignored on RN
    window.__suppressMapClickUntil = 0;

    function clearLongPress() {
      if (__lpTimer) { clearTimeout(__lpTimer); __lpTimer = null; }
      __lpStart = null;
    }

    function showStationPopup(feature) {
      try {
        const coords = feature.geometry.coordinates;
        const name = feature.properties?.name || feature.properties?.sid || 'Station';
        if (__activePopup) __activePopup.remove();
        __activePopup = new mapboxgl.Popup({ closeButton: false, closeOnClick: true })
          .setLngLat(coords)
          .setHTML(`<div style="font: 600 13px system-ui, sans-serif">${name}</div>`)
          .addTo(map);
      } catch {}
    }

    function showUserLocationPopup(coord) {
      try {
        new mapboxgl.Popup({ closeButton: true, closeOnClick: true })
          .setLngLat(coord)
          .setHTML('<div style="font:600 13px system-ui,sans-serif">Your location</div>')
          .addTo(map);
      } catch (e) {}
    }

    // Start a long-press if finger/mouse is held ~1s without moving much
    function startLongPress(e) {
      if (!e.features || !e.features.length) return;
      const feature = e.features[0];
      __lpStart = e.point;
      clearLongPress();
      __lpTimer = setTimeout(() => {
        showStationPopup(feature);
        // Ignore any click that Mapbox emits right after the long press
        window.__suppressMapClickUntil = Date.now() + 600;
      }, 1000); // 1s press
    }

    function cancelLongPress(e) {
      clearLongPress();
    }

    // If the pointer moves too far, cancel the pending long-press
    function maybeCancelOnMove(e) {
      if (!__lpStart) return;
      const dx = Math.abs(e.point.x - __lpStart.x);
      const dy = Math.abs(e.point.y - __lpStart.y);
      if (dx > 6 || dy > 6) clearLongPress();
    }

    // Bind to the STATION layer (delegated — safe across style reloads)
    map.on('mousedown',   'station-points', startLongPress);
    map.on('touchstart',  'station-points', startLongPress);
    map.on('mouseup',     'station-points', cancelLongPress);
    map.on('touchend',    'station-points', cancelLongPress);
    map.on('dragstart',                    cancelLongPress);
    map.on('move',                         maybeCancelOnMove);

    // Also: if user just taps a station (no long-press), do nothing (no chart)
    // but you could show a tiny highlight here if you want.
    map.on('click', 'station-points', (e) => {
      // intentionally empty — handled by long-press only
    });


    function addSelectionLayers() {
      if (!lastSelectionCenter || lastSelectionRadiusKm == null) {
        if (map.getLayer('selection-circle')) map.removeLayer('selection-circle');
        if (map.getSource('selection-circle')) map.removeSource('selection-circle');
        if (map.getLayer('selected-stations')) map.removeLayer('selected-stations');
        if (map.getSource('selected-stations')) map.removeSource('selected-stations');
        return;
      }

      const circleGeojson = createCircleGeoJSON(lastSelectionCenter, lastSelectionRadiusKm);
      addOrUpdateSource('selection-circle', circleGeojson);
      if (!map.getLayer('selection-circle')) {
        map.addLayer({
          id: 'selection-circle',
          type: 'fill',
          source: 'selection-circle',
          paint: { 'fill-color': '#44f', 'fill-opacity': 0.2 }
        });
      }

      const gj = lastSelectedGeoJSON || { type: 'FeatureCollection', features: [] };
      addOrUpdateSource('selected-stations', gj);
      if (!map.getLayer('selected-stations')) {
        map.addLayer({
          id: 'selected-stations',
          type: 'circle',
          source: 'selected-stations',
          paint: { 'circle-radius': 6, 'circle-color': '#44f' }
        });
      }
    }

    function readdAllLayers() {
      addKmlLayers();
      addStationsLayer();
      addSelectionLayers();

      if (window.__gridRows && window.__gridRows.length) {
        ensureGridLayers();
        map.getSource("intensity-grid").setData(window.__gridBaseGeoJSON);
        map.getSource("intensity-grid-highlight").setData(window.__gridHighlightGeoJSON);

        const hasGrid = !!window.__gridMode;
        map.setLayoutProperty("intensity-grid-fill", "visibility", hasGrid ? "visible" : "none");
        map.setLayoutProperty("intensity-grid-line", "visibility", hasGrid ? "visible" : "none");
        map.setLayoutProperty("intensity-grid-highlight-fill", "visibility", hasGrid ? "visible" : "none");
        map.setLayoutProperty("grid-draw-rect-line", "visibility", hasGrid ? "visible" : "none");
      }

      if (lastUserLoc) {
        upsertUserLocation(lastUserLoc.lng, lastUserLoc.lat, lastUserLoc.accuracy);
      }
    }

    // Legend
    function renderLegend(bins = [], unit = '') {
      let el = document.getElementById('legend');
      if (!el) {
        el = document.createElement('div');
        el.id = 'legend';
        Object.assign(el.style, {
          position: 'absolute',
          left: '10px',
          top: '10px',
          background: 'rgba(255,255,255,0.95)',
          borderRadius: '10px',
          padding: '10px',
          fontFamily: 'system-ui, sans-serif',
          fontSize: '12px',
          boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
          zIndex: 9999,
          maxHeight: '90vh',
          overflowY: 'auto'
        });
        document.body.appendChild(el);
      }
      el.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Precipitation (${unit})</div>`;
      const rows = [...bins].reverse().map(b => `
        <div style="display:flex;align-items:center;margin:2px 0">
          <div style="width:14px;height:14px;background:${b.color};border:1px solid #222;margin-right:6px"></div>
          <div>${Number.isFinite(b.upTo) ? b.upTo.toFixed(b.upTo >= 1 ? 2 : 2) : '∞'}</div>
        </div>
      `);
      el.innerHTML += rows.join('');
    }

    // ---------------------------
    // KML plumbing
    // ---------------------------
    function showKmlList(kmlList) {
      kmlFeatures = [];
      let allFeatures = [];
      for (const {id, raw, name} of kmlList) {
        const geojson = parseKmlWithId(raw, id, name);
        geojson.features.forEach(f => {
          kmlFeatures.push({id, geojson: f, name, bbox: featureBounds(f), type: f.geometry.type});
          allFeatures.push(f);
        });
      }
      lastKmlAllGeoJSON = { type: 'FeatureCollection', features: allFeatures };
      addKmlLayers();
    }

    function flyToKml(raw) {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(raw, "text/xml");
      const geojson = toGeoJSON.kml(kmlDoc);
      if (geojson.features && geojson.features.length) {
        const f = geojson.features[0];
        if (f.geometry.type === 'Point') {
          const center = f.geometry.coordinates;
          map.flyTo({center, zoom: 13, essential: true});
        } else {
          const bbox = featureBounds(f);
          if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
        }
      }
    }

    // ---------------------------
    // Click handlers
    // ---------------------------
    map.on('click', 'kml-point', function(e) {
      if (e.features.length) {
        const coords = e.features[0].geometry.coordinates;
        map.flyTo({center: coords, zoom: 13, essential: true});
      }
    });
    map.on('click', 'kml-polygon', function(e) {
      if (e.features.length) {
        const bbox = featureBounds(e.features[0]);
        if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
      }
    });
    map.on('click', function(e) {
      if (window.__gridMode && window.__gridDrawMode) return;
      // 1) if this click comes right after a long-press, ignore
      if (window.__suppressMapClickUntil && Date.now() < window.__suppressMapClickUntil) return;

      // 2) if the click landed on a station, ignore (long-press is the only action on stations)
      const hits = map.queryRenderedFeatures(e.point, { layers: ['station-points'] });
      if (hits && hits.length) return;

      // 3) otherwise: this is a globe tap → send to RN so it can open the chart
      if (window.ReactNativeWebView && window.stationsList && window.stationsList.length) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'MAP_CLICK',
          payload: {
            lng: e.lngLat.lng,
            lat: e.lngLat.lat,
            allStations: window.stationsList
          }
        }));
      }
    });
    map.on("mousedown", (e) => {
      if (!window.__gridMode || !window.__gridDrawMode) return;
      if (e.originalEvent.button !== 0) return;

      __gridIsDrawing = true;
      __gridStartPoint = e.lngLat;
      map.dragPan.disable();
      map.getCanvas().style.cursor = "crosshair";
      map.on("mousemove", onGridMouseMove);
    });

    map.on("mouseup", () => {
      if (!window.__gridMode || !window.__gridDrawMode || !__gridIsDrawing) return;

      __gridIsDrawing = false;
      map.off("mousemove", onGridMouseMove);
      map.dragPan.enable();
      map.getCanvas().style.cursor = "";

      finishGridSelection();
    });

    function onGridTouchStart(e) {
      if (!window.__gridMode || !window.__gridDrawMode) return;

      __gridIsDrawing = true;
      __gridStartPoint = e.lngLat;
      map.dragPan.disable();

      __gridRectCoords = [[
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
      ]];

      updateGridRect(__gridRectCoords);
    }

    function onGridTouchMove(e) {
      if (!window.__gridMode || !window.__gridDrawMode || !__gridIsDrawing || !__gridStartPoint) return;

      const endPoint = e.lngLat;

      __gridRectCoords = [[
        [__gridStartPoint.lng, __gridStartPoint.lat],
        [endPoint.lng, __gridStartPoint.lat],
        [endPoint.lng, endPoint.lat],
        [__gridStartPoint.lng, endPoint.lat],
        [__gridStartPoint.lng, __gridStartPoint.lat],
      ]];

      updateGridRect(__gridRectCoords);
    }

    function onGridTouchEnd() {
      if (!window.__gridMode || !window.__gridDrawMode || !__gridIsDrawing) return;

      __gridIsDrawing = false;
      map.dragPan.enable();

      finishGridSelection();
    }

    map.on("touchstart", onGridTouchStart);
    map.on("touchmove", onGridTouchMove);
    map.on("touchend", onGridTouchEnd);
    map.on("mouseleave", () => {
      if (!__gridIsDrawing) return;

      __gridIsDrawing = false;
      map.off("mousemove", onGridMouseMove);
      map.dragPan.enable();
      map.getCanvas().style.cursor = "";

      if (map.getSource("grid-draw-rect")) {
        map.getSource("grid-draw-rect").setData({
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [[]] },
        });
      }

      __gridRectCoords = [];
      __gridStartPoint = null;
    });


    // ---------------------------
    // RN <-> WebView messaging
    // ---------------------------
    window.addEventListener('message', function (event) {
      try {
        let msg = JSON.parse(event.data);

        if (msg.type === 'KML_LIST') {
          showKmlList(msg.payload);
        }
        else if (msg.type === 'KML_FLYTO') {
          flyToKml(msg.payload);
        }
        else if (msg.type === 'STATIONS') {
          window.stationsList = msg.payload || [];
          addStationsLayer();
        }
        else if (msg.type === 'RADIUS_UPDATE') {
          window.radiusKm = msg.payload.radiusKm;
        }
        else if (msg.type === 'STATIONS_IN_RADIUS') {
          const { stations, center, radiusKm } = msg.payload;
          lastSelectionCenter = center;
          lastSelectionRadiusKm = radiusKm;
          lastSelectedGeoJSON = {
            type: "FeatureCollection",
            features: (stations || []).map(station => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [parseFloat(station.longitude), parseFloat(station.latitude)]
              },
              properties: { name: station.stationName }
            }))
          };
          addSelectionLayers();
          if (stations && stations.length > 0) {
            map.flyTo({ center: lastSelectedGeoJSON.features[0].geometry.coordinates, zoom: Math.max(map.getZoom(), 8) });
          }
        }
        else if (msg.type === 'KML_GET_CENTER') {
          const { kmlId } = msg.payload || {};
          if (!kmlId) return;
          const feat = (kmlFeatures || []).find(f => f.id === kmlId);
          if (!feat) return;

          let center = null;
          if (feat.type === 'Point') {
            center = feat.geojson.geometry.coordinates; // [lng, lat]
          } else {
            const bbox = featureBounds(feat.geojson);
            if (bbox) center = [(bbox[0][0] + bbox[1][0]) / 2, (bbox[0][1] + bbox[1][1]) / 2];
          }
          if (center && window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'KML_CENTER',
              payload: { kmlId, center }
            }));
          }
        }
        else if (msg.type === 'SET_STYLE') {
          const { styleURL } = msg.payload || {};
          if (!styleURL) return;
          map.setStyle(styleURL);
        }
        else if (msg.type === 'STATION_INTENSITY') {
          window.stationColorMap = msg.payload?.styles || {};
          addStationsLayer();
          if (msg.payload?.legendBins) {
            renderLegend(msg.payload.legendBins, msg.payload?.legend?.unit || '');
          }
        }
        else if (msg.type === 'SET_STATIONS_VISIBLE') {
          setStationsVisibility(!!msg.payload?.visible);
        }
        else if (msg.type === "USER_LOCATION") {
          const { lat, lon, accuracy } = msg.payload || {};
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            const acc = Number.isFinite(accuracy) ? accuracy : 30;
            // optional: ignore if identical to last
            if (!lastUserLoc || lastUserLoc.lon !== lon || lastUserLoc.lat !== lat || lastUserLoc.accuracy !== acc) {
              upsertUserLocation(lon, lat, acc);
            }
          }
        }
        else if (msg.type === "USER_LOCATION_CLEAR") {
          removeUserLocation();
        }

        else if (msg.type === 'REQUEST_STATIONS_SNAPSHOT') {
          if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'STATIONS_SNAPSHOT',
              payload: (window.stationsList || [])
            }));
          }
        }
        else if (msg.type === 'INTENSITY_RESET') {
          window.stationColorMap = {};
          clearGrid();
          window.__gridMode = false;
          window.__gridDrawMode = false;

          // restore all stations if you were filtering in INTENSITY_REQUEST
          if (window.__intensityMode && window.__originalStationsList && window.__originalStationsList.length) {
            window.stationsList = window.__originalStationsList.slice();
            window.__originalStationsList = [];
          }
          // remove legend if present
          const lg = document.getElementById('legend'); if (lg) lg.remove();
          // redraw
          addStationsLayer();
          window.__intensityMode = false;
        }
        else if (msg.type === 'GRID_DATA_SET') {
          const rows = msg.payload?.rows || [];
          const interval = Number(msg.payload?.interval || 0.5);
          const metric = msg.payload?.metric || 'precip';

          window.__gridMetric = metric;
          renderGridFromRows(rows, interval);
        }
        else if (msg.type === 'GRID_MODE_SET') {
          window.__gridMode = !!msg.payload?.enabled;
          ensureGridLayers();

          if (map.getLayer("intensity-grid-fill")) {
            map.setLayoutProperty("intensity-grid-fill", "visibility", window.__gridMode ? "visible" : "none");
          }
          if (map.getLayer("intensity-grid-line")) {
            map.setLayoutProperty("intensity-grid-line", "visibility", window.__gridMode ? "visible" : "none");
          }
          if (map.getLayer("intensity-grid-highlight-fill")) {
            map.setLayoutProperty("intensity-grid-highlight-fill", "visibility", window.__gridMode ? "visible" : "none");
          }
          if (map.getLayer("grid-draw-rect-line")) {
            map.setLayoutProperty("grid-draw-rect-line", "visibility", window.__gridMode ? "visible" : "none");
          }
        }
        else if (msg.type === 'GRID_DRAW_MODE') {
          window.__gridDrawMode = !!msg.payload?.enabled;
        }
        else if (msg.type === 'GRID_CLEAR') {
          clearGrid();
        }
      } catch (e) {
        console.log("[postMessage] Error: " + e);
      }
    });

  </script>
</body>
</html>
