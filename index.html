<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Globe - KML Debug Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/togeojson"></script>
  <style>
    html, body, #map { height: 100%; width: 100%; margin: 0; padding: 0; }
    #debugLog { position:absolute;top:0;left:0;z-index:9999;color:#fff;background:rgba(0,0,0,0.7);max-width:100vw;max-height:200px;overflow:auto;font-size:12px }
    .mapboxgl-ctrl-attrib { display: none !important; }
    .mapboxgl-ctrl-logo { display: none !important; }
  </style>  
</head>
<body>
  <div id="map"></div>
  <pre id="debugLog"></pre>
  <script>
    // ---------------------------
    // Global caches
    // ---------------------------
    window.stationsList = [];
    window.radiusKm = 100;
    window.stationColorMap = {}; // stationId -> { color, value }
    window.__stationsVisible = false; // default OFF
    function setStationsVisibility(vis) {
      window.__stationsVisible = !!vis;
      const lyr = map.getLayer('station-points');
      if (lyr) {
        map.setLayoutProperty('station-points', 'visibility', window.__stationsVisible ? 'visible' : 'none');
      }
    }
    if (window.ReactNativeWebView) {
    window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'WEB_READY' }));
    }

    let lastKmlAllGeoJSON = null;
    let lastSelectedGeoJSON = null;
    let lastSelectionCenter = null;
    let lastSelectionRadiusKm = null;
    let kmlFeatures = [];
    let lastUserLoc = null;
    let autoCentered = false;

    function createCircleGeoJSONMeters(center, radiusMeters, points = 64) {
    const [lng, lat] = center;
    const radiusKm = Math.max((radiusMeters || 0) / 1000, 0.005); // min ring
    const coords = [];
    for (let i = 0; i <= points; i++) {
      const a = (i / points) * 2 * Math.PI;
      const dx = radiusKm * Math.cos(a);
      const dy = radiusKm * Math.sin(a);
      const dLng = dx / (111.32 * Math.cos(lat * Math.PI / 180));
      const dLat = dy / 110.574;
      coords.push([lng + dLng, lat + dLat]);
    }
    return {
      type: "FeatureCollection",
      features: [{ type: "Feature", geometry: { type: "Polygon", coordinates: [coords] }, properties: {} }]
      };
    }

    function upsertUserLocation(lng, lat, accuracy) {
    lastUserLoc = { lng, lat, accuracy };

      const point = {
        type: "FeatureCollection",
        features: [{ type: "Feature", geometry: { type: "Point", coordinates: [lng, lat] }, properties: {} }]
      };
      const ring = createCircleGeoJSONMeters([lng, lat], accuracy);

      addOrUpdateSource("user-location", point);
      addOrUpdateSource("user-location-accuracy", ring);

      if (!map.getLayer("user-location-accuracy")) {
        map.addLayer({
          id: "user-location-accuracy",
          type: "fill",
          source: "user-location-accuracy",
          paint: { "fill-color": "#3b82f6", "fill-opacity": 0.12 }
        });
      }
      if (!map.getLayer("user-location-dot")) {
        map.addLayer({
          id: "user-location-dot",
          type: "circle",
          source: "user-location",
          paint: {
            "circle-radius": 6,
            "circle-color": "#26d81dff",
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff"
          }
        });
      }
    }

    function removeUserLocation() {
      lastUserLoc = null;
      if (map.getLayer("user-location-dot")) map.removeLayer("user-location-dot");
      if (map.getLayer("user-location-accuracy")) map.removeLayer("user-location-accuracy");
      if (map.getSource("user-location")) map.removeSource("user-location");
      if (map.getSource("user-location-accuracy")) map.removeSource("user-location-accuracy");
    }

    function debug(msg) {
      const el = document.getElementById('debugLog');
      if (!el) return;
      el.textContent += (typeof msg === 'object' ? JSON.stringify(msg, null, 2) : msg) + '\n';
      el.scrollTop = el.scrollHeight;
    }
    console.log = debug;
    console.error = debug;

    // ---------------------------
    // Map init
    // ---------------------------
    mapboxgl.accessToken = 'pk.eyJ1Ijoic2hhd25hY2ciLCJhIjoiY21idDFqb25jMHNvcDJpcHZmd28xNWUzayJ9.ruwUPA5XBDkHEoM6pr_bkw';
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      projection: 'globe',
      attributionControl: false,
      zoom: 3.2,
      center: [-98.5, 39.8] // North America default
    });

    map.on('style.load', () => {
      map.setFog({});
      readdAllLayers();
    });
    map.on('load', () => {
    if (window.ReactNativeWebView) {
      window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'MAP_READY' }));
      }
    });

    // ---------------------------
    // Helpers
    // ---------------------------
    function featureBounds(feature) {
      if (!feature) return null;
      let coords = [];
      if (feature.geometry.type === 'Polygon') {
        coords = feature.geometry.coordinates.flat();
      } else if (feature.geometry.type === 'Point') {
        coords = [feature.geometry.coordinates];
      } else if (feature.geometry.type === 'MultiPolygon') {
        coords = feature.geometry.coordinates.flat(2);
      }
      if (!coords.length) return null;
      let minLng = coords[0][0], minLat = coords[0][1], maxLng = coords[0][0], maxLat = coords[0][1];
      coords.forEach(([lng, lat]) => {
        minLng = Math.min(minLng, lng);
        minLat = Math.min(minLat, lat);
        maxLng = Math.max(maxLng, lng);
        maxLat = Math.max(maxLat, lat);
      });
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function parseKmlWithId(raw, id, name) {
      try {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(raw, "text/xml");
        const geojson = toGeoJSON.kml(kmlDoc);
        geojson.features.forEach(f => {
          f.properties = f.properties || {};
          f.properties.kmlId = id;
          f.properties.kmlName = name || id;
        });
        return geojson;
      } catch (e) {
        return { type: "FeatureCollection", features: [] };
      }
    }

    function addOrUpdateSource(id, data) {
      if (map.getSource(id)) {
        map.getSource(id).setData(data);
      } else {
        map.addSource(id, { type: 'geojson', data });
      }
    }

    function addKmlLayers() {
      if (!lastKmlAllGeoJSON) return;
      addOrUpdateSource('kml-data', lastKmlAllGeoJSON);

      if (!map.getLayer('kml-polygon')) {
        map.addLayer({
          id: 'kml-polygon',
          type: 'fill',
          source: 'kml-data',
          paint: { 'fill-color': '#00FF80', 'fill-opacity': 0.4 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-outline')) {
        map.addLayer({
          id: 'kml-outline',
          type: 'line',
          source: 'kml-data',
          paint: { 'line-color': '#fff', 'line-width': 2 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-point')) {
        map.addLayer({
          id: 'kml-point',
          type: 'circle',
          source: 'kml-data',
          paint: { 'circle-radius': 6, 'circle-color': '#ff0' },
          filter: ['==', '$type', 'Point']
        });
      }
    }

    function addStationsLayer() {
      const stylesMap = window.stationColorMap || {};
      const stationFeatures = (window.stationsList || [])
        .filter(st => st.latitude != null && st.longitude != null &&
                      !isNaN(Number(st.latitude)) && !isNaN(Number(st.longitude)))
        .map(st => {
          const sid = String(st.stationId ?? st.station_id ?? '');
          const style = stylesMap[sid] || null;
          return {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [parseFloat(st.longitude), parseFloat(st.latitude)] },
            properties: {
              name: st.stationName || st.name || sid,
              sid,
              col: style ? style.color : null,
              intensity: style ? style.value : null
            }
          };
        });
      const gj = { type: 'FeatureCollection', features: stationFeatures };
      addOrUpdateSource('stations', gj);
      if (!map.getLayer('station-points')) {
        map.addLayer({
          id: 'station-points',
          type: 'circle',
          source: 'stations',
          paint: {
            'circle-radius': 4,
            'circle-color': ['coalesce', ['get', 'col'], '#ff5500'],
            'circle-stroke-color': '#000',
            'circle-stroke-width': ['case', ['has', 'intensity'], 0.5, 0.2]
          },
          layout: {
            visibility: window.__stationsVisible ? 'visible' : 'none'
          }
        });
      } else {
        map.setLayoutProperty('station-points', 'visibility', window.__stationsVisible ? 'visible' : 'none');
      }

    }

    function createCircleGeoJSON(center, radiusKm, points = 64) {
      const [lng, lat] = center;
      const coords = [];
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        const dx = radiusKm * Math.cos(angle);
        const dy = radiusKm * Math.sin(angle);
        const dLng = dx / (111.32 * Math.cos(lat * Math.PI / 180));
        const dLat = dy / 110.574;
        coords.push([lng + dLng, lat + dLat]);
      }
      return {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: { type: 'Polygon', coordinates: [coords] },
          properties: {}
        }]
      };
    }

        // --- long-press state ---
    let __lpTimer = null;
    let __lpStart = null;
    let __activePopup = null;
    // When we long-press a station, set this so the subsequent 'click' is ignored on RN
    window.__suppressMapClickUntil = 0;

    function clearLongPress() {
      if (__lpTimer) { clearTimeout(__lpTimer); __lpTimer = null; }
      __lpStart = null;
    }

    function showStationPopup(feature) {
      try {
        const coords = feature.geometry.coordinates;
        const name = feature.properties?.name || feature.properties?.sid || 'Station';
        if (__activePopup) __activePopup.remove();
        __activePopup = new mapboxgl.Popup({ closeButton: false, closeOnClick: true })
          .setLngLat(coords)
          .setHTML(`<div style="font: 600 13px system-ui, sans-serif">${name}</div>`)
          .addTo(map);
      } catch {}
    }

    // Start a long-press if finger/mouse is held ~1s without moving much
    function startLongPress(e) {
      if (!e.features || !e.features.length) return;
      const feature = e.features[0];
      __lpStart = e.point;
      clearLongPress();
      __lpTimer = setTimeout(() => {
        showStationPopup(feature);
        // Ignore any click that Mapbox emits right after the long press
        window.__suppressMapClickUntil = Date.now() + 600;
      }, 1000); // 1s press
    }

    function cancelLongPress(e) {
      clearLongPress();
    }

    // If the pointer moves too far, cancel the pending long-press
    function maybeCancelOnMove(e) {
      if (!__lpStart) return;
      const dx = Math.abs(e.point.x - __lpStart.x);
      const dy = Math.abs(e.point.y - __lpStart.y);
      if (dx > 6 || dy > 6) clearLongPress();
    }

    // Bind to the STATION layer (delegated — safe across style reloads)
    map.on('mousedown',   'station-points', startLongPress);
    map.on('touchstart',  'station-points', startLongPress);
    map.on('mouseup',     'station-points', cancelLongPress);
    map.on('touchend',    'station-points', cancelLongPress);
    map.on('dragstart',                    cancelLongPress);
    map.on('move',                         maybeCancelOnMove);

    // Also: if user just taps a station (no long-press), do nothing (no chart)
    // but you could show a tiny highlight here if you want.
    map.on('click', 'station-points', (e) => {
      // intentionally empty — handled by long-press only
    });


    function addSelectionLayers() {
      if (!lastSelectionCenter || lastSelectionRadiusKm == null) {
        if (map.getLayer('selection-circle')) map.removeLayer('selection-circle');
        if (map.getSource('selection-circle')) map.removeSource('selection-circle');
        if (map.getLayer('selected-stations')) map.removeLayer('selected-stations');
        if (map.getSource('selected-stations')) map.removeSource('selected-stations');
        return;
      }

      const circleGeojson = createCircleGeoJSON(lastSelectionCenter, lastSelectionRadiusKm);
      addOrUpdateSource('selection-circle', circleGeojson);
      if (!map.getLayer('selection-circle')) {
        map.addLayer({
          id: 'selection-circle',
          type: 'fill',
          source: 'selection-circle',
          paint: { 'fill-color': '#44f', 'fill-opacity': 0.2 }
        });
      }

      const gj = lastSelectedGeoJSON || { type: 'FeatureCollection', features: [] };
      addOrUpdateSource('selected-stations', gj);
      if (!map.getLayer('selected-stations')) {
        map.addLayer({
          id: 'selected-stations',
          type: 'circle',
          source: 'selected-stations',
          paint: { 'circle-radius': 6, 'circle-color': '#44f' }
        });
      }
    }

    function readdAllLayers() {
      addKmlLayers();
      addStationsLayer();
      addSelectionLayers();
      if (lastUserLoc) {
        upsertUserLocation(lastUserLoc.lng, lastUserLoc.lat, lastUserLoc.accuracy);
      } 
    }

    // Legend
    function renderLegend(bins = [], unit = '') {
      let el = document.getElementById('legend');
      if (!el) {
        el = document.createElement('div');
        el.id = 'legend';
        Object.assign(el.style, {
          position: 'absolute',
          left: '10px',
          top: '10px',
          background: 'rgba(255,255,255,0.95)',
          borderRadius: '10px',
          padding: '10px',
          fontFamily: 'system-ui, sans-serif',
          fontSize: '12px',
          boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
          zIndex: 9999,
          maxHeight: '90vh',
          overflowY: 'auto'
        });
        document.body.appendChild(el);
      }
      el.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Precipitation (${unit})</div>`;
      const rows = [...bins].reverse().map(b => `
        <div style="display:flex;align-items:center;margin:2px 0">
          <div style="width:14px;height:14px;background:${b.color};border:1px solid #222;margin-right:6px"></div>
          <div>${Number.isFinite(b.upTo) ? b.upTo.toFixed(b.upTo >= 1 ? 2 : 2) : '∞'}</div>
        </div>
      `);
      el.innerHTML += rows.join('');
    }

    // ---------------------------
    // KML plumbing
    // ---------------------------
    function showKmlList(kmlList) {
      kmlFeatures = [];
      let allFeatures = [];
      for (const {id, raw, name} of kmlList) {
        const geojson = parseKmlWithId(raw, id, name);
        geojson.features.forEach(f => {
          kmlFeatures.push({id, geojson: f, name, bbox: featureBounds(f), type: f.geometry.type});
          allFeatures.push(f);
        });
      }
      lastKmlAllGeoJSON = { type: 'FeatureCollection', features: allFeatures };
      addKmlLayers();
    }

    function flyToKml(raw) {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(raw, "text/xml");
      const geojson = toGeoJSON.kml(kmlDoc);
      if (geojson.features && geojson.features.length) {
        const f = geojson.features[0];
        if (f.geometry.type === 'Point') {
          const center = f.geometry.coordinates;
          map.flyTo({center, zoom: 13, essential: true});
        } else {
          const bbox = featureBounds(f);
          if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
        }
      }
    }

    // ---------------------------
    // Click handlers
    // ---------------------------
    map.on('click', 'kml-point', function(e) {
      if (e.features.length) {
        const coords = e.features[0].geometry.coordinates;
        map.flyTo({center: coords, zoom: 13, essential: true});
      }
    });
    map.on('click', 'kml-polygon', function(e) {
      if (e.features.length) {
        const bbox = featureBounds(e.features[0]);
        if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
      }
    });
    map.on('click', function(e) {
      // 1) if this click comes right after a long-press, ignore
      if (window.__suppressMapClickUntil && Date.now() < window.__suppressMapClickUntil) return;

      // 2) if the click landed on a station, ignore (long-press is the only action on stations)
      const hits = map.queryRenderedFeatures(e.point, { layers: ['station-points'] });
      if (hits && hits.length) return;

      // 3) otherwise: this is a globe tap → send to RN so it can open the chart
      if (window.ReactNativeWebView && window.stationsList && window.stationsList.length) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'MAP_CLICK',
          payload: {
            lng: e.lngLat.lng,
            lat: e.lngLat.lat,
            allStations: window.stationsList
          }
        }));
      }
    });


    // ---------------------------
    // RN <-> WebView messaging
    // ---------------------------
    window.addEventListener('message', function (event) {
      try {
        let msg = JSON.parse(event.data);

        if (msg.type === 'KML_LIST') {
          showKmlList(msg.payload);
        }
        else if (msg.type === 'KML_FLYTO') {
          flyToKml(msg.payload);
        }
        else if (msg.type === 'STATIONS') {
          window.stationsList = msg.payload || [];
          addStationsLayer();
        }
        else if (msg.type === 'RADIUS_UPDATE') {
          window.radiusKm = msg.payload.radiusKm;
        }
        else if (msg.type === 'STATIONS_IN_RADIUS') {
          const { stations, center, radiusKm } = msg.payload;
          lastSelectionCenter = center;
          lastSelectionRadiusKm = radiusKm;
          lastSelectedGeoJSON = {
            type: "FeatureCollection",
            features: (stations || []).map(station => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [parseFloat(station.longitude), parseFloat(station.latitude)]
              },
              properties: { name: station.stationName }
            }))
          };
          addSelectionLayers();
          if (stations && stations.length > 0) {
            map.flyTo({ center: lastSelectedGeoJSON.features[0].geometry.coordinates, zoom: Math.max(map.getZoom(), 8) });
          }
        }
        else if (msg.type === 'KML_GET_CENTER') {
          const { kmlId } = msg.payload || {};
          if (!kmlId) return;
          const feat = (kmlFeatures || []).find(f => f.id === kmlId);
          if (!feat) return;

          let center = null;
          if (feat.type === 'Point') {
            center = feat.geojson.geometry.coordinates; // [lng, lat]
          } else {
            const bbox = featureBounds(feat.geojson);
            if (bbox) center = [(bbox[0][0] + bbox[1][0]) / 2, (bbox[0][1] + bbox[1][1]) / 2];
          }
          if (center && window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'KML_CENTER',
              payload: { kmlId, center }
            }));
          }
        }
        else if (msg.type === 'SET_STYLE') {
          const { styleURL } = msg.payload || {};
          if (!styleURL) return;
          map.setStyle(styleURL);
        }
        else if (msg.type === 'STATION_INTENSITY') {
          window.stationColorMap = msg.payload?.styles || {};
          addStationsLayer();
          if (msg.payload?.legendBins) {
            renderLegend(msg.payload.legendBins, msg.payload?.legend?.unit || '');
          }
        }
        else if (msg.type === 'SET_STATIONS_VISIBLE') {
          setStationsVisibility(!!msg.payload?.visible);
        }
        else if (msg.type === "USER_LOCATION") {
          const { lat, lon, accuracy } = msg.payload || {};
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            const acc = Number.isFinite(accuracy) ? accuracy : 30;
            // optional: ignore if identical to last
            if (!lastUserLoc || lastUserLoc.lon !== lon || lastUserLoc.lat !== lat || lastUserLoc.accuracy !== acc) {
              upsertUserLocation(lon, lat, acc);
            }
          }
        }
        else if (msg.type === "USER_LOCATION_CLEAR") {
          removeUserLocation();
        }

        else if (msg.type === 'REQUEST_STATIONS_SNAPSHOT') {
          if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'STATIONS_SNAPSHOT',
              payload: (window.stationsList || [])
            }));
          }
        }
        else if (msg.type === 'INTENSITY_RESET') {
          window.stationColorMap = {};
          // restore all stations if you were filtering in INTENSITY_REQUEST
          if (window.__intensityMode && window.__originalStationsList && window.__originalStationsList.length) {
            window.stationsList = window.__originalStationsList.slice();
            window.__originalStationsList = [];
          }
          // remove legend if present
          const lg = document.getElementById('legend'); if (lg) lg.remove();
          // redraw
          addStationsLayer();
          window.__intensityMode = false;
        }
      } catch (e) {
        console.log("[postMessage] Error: " + e);
      }
    });

  </script>
</body>
</html>
