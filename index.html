<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Globe - KML Debug Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/togeojson"></script>
  <style>
    html, body, #map { height: 100%; width: 100%; margin: 0; padding: 0; }
    #debugLog { position:absolute;top:0;left:0;z-index:9999;color:#fff;background:rgba(0,0,0,0.7);max-width:100vw;max-height:200px;overflow:auto;font-size:12px }
  </style>
</head>
<body>
  <div id="map"></div>
  <pre id="debugLog"></pre>
  <script>
    // ---------------------------
    // Global caches (so we can re-add after style changes)
    // ---------------------------
    window.stationsList = [];
    window.radiusKm = 100;

    // Keep last-drawn data for re-adding
    let lastKmlAllGeoJSON = null;       // FeatureCollection of all KML features
    let lastSelectedGeoJSON = null;     // FeatureCollection of highlighted/selected stations
    let lastSelectionCenter = null;     // [lng, lat]
    let lastSelectionRadiusKm = null;

    // In-memory KML features with ids for lookups
    let kmlFeatures = [];

    function debug(msg) {
      const el = document.getElementById('debugLog');
      if (!el) return;
      el.textContent += (typeof msg === 'object' ? JSON.stringify(msg, null, 2) : msg) + '\n';
      el.scrollTop = el.scrollHeight;
    }
    console.log = debug;
    console.error = debug;

    // ---------------------------
    // Map init
    // ---------------------------
    mapboxgl.accessToken = 'pk.eyJ1Ijoic2hhd25hY2ciLCJhIjoiY21idDFqb25jMHNvcDJpcHZmd28xNWUzayJ9.ruwUPA5XBDkHEoM6pr_bkw';
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      projection: 'globe',
      attributionControl: false,
      zoom: 2,
      center: [106.9, 47.9]
    });

    map.on('style.load', () => {
      map.setFog({});
      // Re-add everything after ANY style change
      readdAllLayers();
    });

    // ---------------------------
    // Helpers
    // ---------------------------
    function featureBounds(feature) {
      if (!feature) return null;
      let coords = [];
      if (feature.geometry.type === 'Polygon') {
        coords = feature.geometry.coordinates.flat();
      } else if (feature.geometry.type === 'Point') {
        coords = [feature.geometry.coordinates];
      } else if (feature.geometry.type === 'MultiPolygon') {
        coords = feature.geometry.coordinates.flat(2);
      }
      if (!coords.length) return null;
      let minLng = coords[0][0], minLat = coords[0][1], maxLng = coords[0][0], maxLat = coords[0][1];
      coords.forEach(([lng, lat]) => {
        minLng = Math.min(minLng, lng);
        minLat = Math.min(minLat, lat);
        maxLng = Math.max(maxLng, lng);
        maxLat = Math.max(maxLat, lat);
      });
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function parseKmlWithId(raw, id, name) {
      try {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(raw, "text/xml");
        const geojson = toGeoJSON.kml(kmlDoc);
        geojson.features.forEach(f => {
          f.properties = f.properties || {};
          f.properties.kmlId = id;
          f.properties.kmlName = name || id;
        });
        return geojson;
      } catch (e) {
        return { type: "FeatureCollection", features: [] };
      }
    }

    function addOrUpdateSource(id, data) {
      if (map.getSource(id)) {
        map.getSource(id).setData(data);
      } else {
        map.addSource(id, { type: 'geojson', data });
      }
    }

    function addKmlLayers() {
      if (!lastKmlAllGeoJSON) return;
      addOrUpdateSource('kml-data', lastKmlAllGeoJSON);

      if (!map.getLayer('kml-polygon')) {
        map.addLayer({
          id: 'kml-polygon',
          type: 'fill',
          source: 'kml-data',
          paint: { 'fill-color': '#00FF80', 'fill-opacity': 0.4 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-outline')) {
        map.addLayer({
          id: 'kml-outline',
          type: 'line',
          source: 'kml-data',
          paint: { 'line-color': '#fff', 'line-width': 2 },
          filter: ['==', '$type', 'Polygon']
        });
      }
      if (!map.getLayer('kml-point')) {
        map.addLayer({
          id: 'kml-point',
          type: 'circle',
          source: 'kml-data',
          paint: { 'circle-radius': 6, 'circle-color': '#ff0' },
          filter: ['==', '$type', 'Point']
        });
      }
    }

    function addStationsLayer() {
      const stationFeatures = (window.stationsList || [])
        .filter(st => st.latitude != null && st.longitude != null &&
                      !isNaN(Number(st.latitude)) && !isNaN(Number(st.longitude)))
        .map(st => ({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [parseFloat(st.longitude), parseFloat(st.latitude)] },
          properties: { name: st.stationName }
        }));
      const gj = { type: 'FeatureCollection', features: stationFeatures };
      addOrUpdateSource('stations', gj);
      if (!map.getLayer('station-points')) {
        map.addLayer({
          id: 'station-points',
          type: 'circle',
          source: 'stations',
          paint: { 'circle-radius': 3, 'circle-color': '#ff5500' }
        });
      }
    }

    function createCircleGeoJSON(center, radiusKm, points = 64) {
      const [lng, lat] = center;
      const coords = [];
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        const dx = radiusKm * Math.cos(angle);
        const dy = radiusKm * Math.sin(angle);
        const dLng = dx / (111.32 * Math.cos(lat * Math.PI / 180));
        const dLat = dy / 110.574;
        coords.push([lng + dLng, lat + dLat]);
      }
      return {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: { type: 'Polygon', coordinates: [coords] },
          properties: {}
        }]
      };
    }

    function addSelectionLayers() {
      if (!lastSelectionCenter || lastSelectionRadiusKm == null) {
        // still remove old sources if any
        if (map.getLayer('selection-circle')) map.removeLayer('selection-circle');
        if (map.getSource('selection-circle')) map.removeSource('selection-circle');
        if (map.getLayer('selected-stations')) map.removeLayer('selected-stations');
        if (map.getSource('selected-stations')) map.removeSource('selected-stations');
        return;
      }

      // circle
      const circleGeojson = createCircleGeoJSON(lastSelectionCenter, lastSelectionRadiusKm);
      addOrUpdateSource('selection-circle', circleGeojson);
      if (!map.getLayer('selection-circle')) {
        map.addLayer({
          id: 'selection-circle',
          type: 'fill',
          source: 'selection-circle',
          paint: { 'fill-color': '#44f', 'fill-opacity': 0.2 }
        });
      }

      // selected stations
      const gj = lastSelectedGeoJSON || { type: 'FeatureCollection', features: [] };
      addOrUpdateSource('selected-stations', gj);
      if (!map.getLayer('selected-stations')) {
        map.addLayer({
          id: 'selected-stations',
          type: 'circle',
          source: 'selected-stations',
          paint: { 'circle-radius': 6, 'circle-color': '#44f' }
        });
      }
    }

    function readdAllLayers() {
      addKmlLayers();
      addStationsLayer();
      addSelectionLayers();
    }

    // ---------------------------
    // KML plumbing
    // ---------------------------
    function showKmlList(kmlList) {
      kmlFeatures = [];
      let allFeatures = [];
      for (const {id, raw, name} of kmlList) {
        const geojson = parseKmlWithId(raw, id, name);
        geojson.features.forEach(f => {
          kmlFeatures.push({id, geojson: f, name, bbox: featureBounds(f), type: f.geometry.type});
          allFeatures.push(f);
        });
      }
      lastKmlAllGeoJSON = { type: 'FeatureCollection', features: allFeatures };
      addKmlLayers();
    }

    function flyToKml(raw) {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(raw, "text/xml");
      const geojson = toGeoJSON.kml(kmlDoc);
      if (geojson.features && geojson.features.length) {
        const f = geojson.features[0];
        if (f.geometry.type === 'Point') {
          const center = f.geometry.coordinates;
          map.flyTo({center, zoom: 13, essential: true});
        } else {
          const bbox = featureBounds(f);
          if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
        }
      }
    }

    // ---------------------------
    // Click handlers
    // ---------------------------
    map.on('click', 'kml-point', function(e) {
      if (e.features.length) {
        const coords = e.features[0].geometry.coordinates;
        map.flyTo({center: coords, zoom: 13, essential: true});
      }
    });
    map.on('click', 'kml-polygon', function(e) {
      if (e.features.length) {
        const bbox = featureBounds(e.features[0]);
        if (bbox) map.fitBounds(bbox, {padding: 60, duration: 1200});
      }
    });
    map.on('click', function(e) {
      // Don't fire when clicking a feature; only background.
      if (e.features && e.features.length > 0) return;
      // Send click coordinates and the list of all stations to React Native
      if (window.ReactNativeWebView && window.stationsList && window.stationsList.length) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'MAP_CLICK',
          payload: {
            lng: e.lngLat.lng,
            lat: e.lngLat.lat,
            allStations: window.stationsList
          }
        }));
      }
    });

    // ---------------------------
    // RN <-> WebView messaging
    // ---------------------------
    window.addEventListener('message', function (event) {
      try {
        let msg = JSON.parse(event.data);

        if (msg.type === 'KML_LIST') {
          showKmlList(msg.payload);
        }
        else if (msg.type === 'KML_FLYTO') {
          flyToKml(msg.payload);
        }
        else if (msg.type === 'STATIONS') {
          window.stationsList = msg.payload || [];
          addStationsLayer();
        }
        else if (msg.type === 'RADIUS_UPDATE') {
          window.radiusKm = msg.payload.radiusKm;
        }
        else if (msg.type === 'STATIONS_IN_RADIUS') {
          const { stations, center, radiusKm } = msg.payload;
          lastSelectionCenter = center;
          lastSelectionRadiusKm = radiusKm;
          lastSelectedGeoJSON = {
            type: "FeatureCollection",
            features: (stations || []).map(station => ({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [parseFloat(station.longitude), parseFloat(station.latitude)]
              },
              properties: { name: station.stationName }
            }))
          };
          addSelectionLayers();
          if (stations && stations.length > 0) {
            map.flyTo({ center: lastSelectedGeoJSON.features[0].geometry.coordinates, zoom: Math.max(map.getZoom(), 8) });
          }
        }
        else if (msg.type === 'KML_GET_CENTER') {
          const { kmlId } = msg.payload || {};
          if (!kmlId) return;
          const feat = (kmlFeatures || []).find(f => f.id === kmlId);
          if (!feat) return;

          let center = null;
          if (feat.type === 'Point') {
            center = feat.geojson.geometry.coordinates; // [lng, lat]
          } else {
            const bbox = featureBounds(feat.geojson);
            if (bbox) center = [(bbox[0][0] + bbox[1][0]) / 2, (bbox[0][1] + bbox[1][1]) / 2];
          }
          if (center && window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'KML_CENTER',
              payload: { kmlId, center }
            }));
          }
        }
        else if (msg.type === 'SET_STYLE') {
          // NEW: switch base map style; on 'style.load' we'll re-add layers
          const { styleURL } = msg.payload || {};
          if (!styleURL) return;
          map.setStyle(styleURL);
        }
      } catch (e) {
        console.log("[postMessage] Error: " + e);
      }
    });

    // Fallback marker if nothing loads quickly
    setTimeout(() => {
      if (!map.getSource('kml-data')) {
        lastKmlAllGeoJSON = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: { type: "Point", coordinates: [106.9, 47.9] },
              properties: { kmlId: "fallback", kmlName: "Timeout Marker" }
            }
          ]
        };
        addKmlLayers();
      }
    }, 2000);
  </script>
</body>
</html>
